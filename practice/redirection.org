#+TITLE:Redirection
#+AUTHOR:Redirection
#+SUBTITLE:Redirection
#+STARTUP:overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :exports both
#+PROPERTY: header-args:bash :results output
* README

  * I/O redirection is the coolest command line feature

  * Important commands include:
    - ~cat~ to concatenate files
    - ~sort~ to sort lines of text
    - ~uniq~ to report or omit repeated lines
    - ~grep~ to print lines matching a pattern
    - ~wc~ to print file newline, word, and byte counts
    - ~head~ to output the first part of a file
    - ~tail~ to output the last part of a file
    - ~tee~ to read from ~stdin~ and write to ~stdout~ and files

  * ~stdin~, ~stdout~ and ~stderr~ are special files

  * [ ] Execute the following commands in your REPL of choice. I'll
    do it in GNU Emacs Org Mode, of course.

* Redirecting standard output

  * [X] It's often useful to store results in a file. What does the
    command in [[redirect]] do?

    #+name: redirect
    #+begin_src bash :results silent
      ls -l /usr/bin > ls-output.txt
    #+end_src

  * [X] Let's look at the file from the outside first.

    #+name: ls
    #+begin_src bash
      ls -lh ls-output.txt
    #+end_src

    #+RESULTS: ls
    : -rw-r--r-- 1 pi pi 81K Mar  7 21:43 ls-output.txt

  * [X] Let's look at the first and the last part of the file

    #+name: headtail
    #+begin_src bash :results output
      head --lines=3 ls-output.txt
      tail --lines=2 ls-output.txt
    #+end_src

    #+RESULTS: headtail
    : total 205792
    : -rwxr-xr-x 1 root root       42884 Sep 22  2020 [
    : -rwxr-xr-x 1 root root          39 Aug 15  2020 7z
    : -rwxr-xr-x 1 root root        1842 Mar  2  2021 zmore
    : -rwxr-xr-x 1 root root        4553 Mar  2  2021 znew


  * [X] We redirect again, this time using a directory that does not
    exist. This results in an error - but why is it
    not sent to the file instead of ~stdout~?

    #+name: redirect1
    #+begin_src bash :results silent
      ls -l /bin/usr > ls-output.txt
    #+end_src

  * [X] What happened to the output file? It's empty!

    #+name: ls1
    #+begin_src bash
      ls -l ls-output.txt
    #+end_src

    #+RESULTS: ls1
    : -rw-r--r-- 1 pi pi 0 Mar  7 21:39 ls-output.txt

  * [X] If you ever want to create a new empty file (instead of
    using the ~touch~ command), you can use ~>~ without origin
    (empty stdout).

    #+name: redirect2
    #+begin_src bash
      > ls-output.txt
      ls -l ls-output.txt
    #+end_src

    #+RESULTS: redirect2
    : -rw-r--r-- 1 pi pi 0 Mar  7 21:41 ls-output.txt

  * [X] To append redirected output to a file instead of overwriting
    it from the beginning, use ~>>~. Let's test this - compare with
    the initial size of the file (81K).

    #+name: redirect3
    #+begin_src bash
      ls -l /usr/bin >> ls-output.txt
      ls -l /usr/bin >> ls-output.txt
      ls -l /usr/bin >> ls-output.txt
      ls -lh ls-output.txt
    #+end_src

    #+RESULTS: redirect3
    : -rw-r--r-- 1 pi pi 772K Mar  7 21:43 ls-output.txt

* Redirecting standard error

  * [ ] To redirect standard error, use its *file descriptor*

  * [ ] File descriptors are internal steam references.

    | STREAM | FILE DESCRIPTOR |
    |--------+-----------------|
    | stdin  |               0 |
    | stdout |               1 |
    | stderr |               2 |

  * [ ] We redirect stderr with ~2>~. We use the command from before
    that tries to list a non-existing directory producing an error.

    #+name: stderr1
  #+begin_src bash
    ls -l /bin/usr 2> ls-error.txt
    ls -lh ls-error.txt
  #+end_src

  #+RESULTS:
  : -rw-r--r-- 1 pi pi 56 Mar  7 21:55 ls-error.txt

  * [ ] What if we want to redirect both stdout and stderr to the same
    file to capture all output in one place?

  * [ ] Traditional method: use ~2>&1~ - "redirect stderr AND stdout":
    first we redirect stdout to a file, and then we redirect stderr
    (2) to stdout (1).

    #+name: stderr2
    #+begin_src bash
      ls -l /bin/usr > ls-output.txt 2>&1
      ls -lh ls-output.txt
    #+end_src

    #+RESULTS: stderr2
    : -rw-r--r-- 1 pi pi 56 Mar  7 22:07 ls-output.txt

  * [ ] The redirection of standard error must always occur *after*
    redirecting standard output. If the order is changed, stderr is
    directed to the screen instead. Try it yourself:

    1) create an empty file ~output.txt~ using >, and redirect both
       stdout and stderr to it.

       #+name: stderr3
       #+begin_src bash :results output
         ls -l /bin/usr >output.txt 2>&1
         cat output.txt
       #+end_src

       #+RESULTS: stderr3
       : ls: cannot access '/bin/usr': No such file or directory

    2) Change the order of the redirection: first redirect stdout and
       stderr, then redirect to a file ~output1.txt~ with >.

       #+name: stderr4
       #+begin_src bash :results output
         ls -l /bin/usr 2>&1 >output1.txt
         ls -lh output1.txt
       #+end_src

       #+RESULTS: stderr4
       : ls: cannot access '/bin/usr': No such file or directory
       : -rw-r--r-- 1 pi pi 0 Mar  7 22:17 output1.txt

  * [ ] There is a more streamline (but also more obscure) method for
    combined redirection with the single notation ~&>~.

    #+name: stderr5
    #+begin_src bash
      ls -l /bin/usr &> ls-output.txt
      cat ls-output.txt
    #+end_src

    #+RESULTS: stderr5
    : ls: cannot access '/bin/usr': No such file or directory

  * [ ] Can you append stdout and stderr to a single file, too? Write
    and execute the command for appending with the single notation and
    the appending redirection operator!

    #+name: stderr6
    #+begin_src bash :results output
      ls -l /bin/usr &>> ls-output.txt
      cat ls-output.txt
    #+end_src

    #+RESULTS: stderr6
    : ls: cannot access '/bin/usr': No such file or directory
    : ls: cannot access '/bin/usr': No such file or directory

  * [ ] Silence is golden: sometimes you just want to throw output
    away - like error or status messages. To do this, we redirect to a
    special file called ~/dev/null~, also called the "bit bucket", or
    the "black hole".

    Write a command to redirect stderr from the error message, then
    list the bit bucket file.

    #+name: bitbucket
    #+begin_src bash 
      ls -l /bin/usr 2> /dev/null
      ls -lh /dev/null
    #+end_src

    #+RESULTS: bitbucket
    : crw-rw-rw- 1 root root 1, 3 Mar  7 09:17 /dev/null
    : crw-rw-rw- 1 root root 1, 3 Mar  7 09:17 /dev/null

    ~/dev/null~ is a special character file (hence the letter ~c~ in
    the listing). The term is a Unix culture fix point ([[https://en.wikipedia.org/wiki/Null_device][see
    Wikipedia]]).


* Redirecting standard input

  
