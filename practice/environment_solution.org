#+TITLE:The Environment
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:environment practice for CSC420 Operating Systems Spring 2022 Lyon College
#+STARTUP:overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :results output
#+PROPERTY: header-args:bash :exports both
* README

  * This file accompanies lectures on the shell and ~bash(1)~. To gain
    practice, you should type along in your own Org-mode file. You
    have to have Emacs and my ~.emacs~ file installed on your PC or
    the Pi you're working with.

  * To make this easier, use the auto expansion (~<s~). This will only
    work if you have my ~.emacs~ file ([[https://tinyurl.com/lyonemacs][from GDrive]]) installed.

  * Add the following two lines at the top of your file, and activate
    each line with ~C-c C-c~ (this is confirmed in the echo area as
    ~Local setup has been refreshed~)):
    #+begin_example
    #+PROPERTY: header-args:bash :results output
    #+end_example

  * Remember that ~C-M-\~ inside a code block indents syntactically
    (on Windows, this may only work if you have a marked region - set
    the mark with ~C-SPC~).
* What is it?

  * The environment is the information retained by the shell about our
    shell session

  * Programs use the data stored in the environment for
    configuration - e.g. when installing files, setting permissions

  * Knowing the environment helps us customize our shell experience
    (including shell scripting)

  * Types of data stored in the environment:

    | DATA                  | DESCRIPTION    | EXAMPLE             |
    |-----------------------+----------------+---------------------|
    | Shell variables       | Placed by bash | ~$PWD~              |
    | Environment variables | Placed by OS   | ~$HOME~             |
    | Aliases               | User-defined   | ~alias ll='ls -lh'~ |
    | Shell functions       | User-defined   | ~hello.sh~          |

    #+name: hello.sh
    #+begin_src bash
      !# /usr/bin/bash
      echo Hello world
    #+end_src

* Examining the environment

  * [ ] You can use the builtin bash programs ~set~, or the program
    ~printenv~ to view the environment.

    Pipe the output of ~printenv~ into ~cat~ to view it.

    #+name: environment
    #+begin_src bash :results output
      printenv | cat
    #+end_src

    #+RESULTS: environment
    #+begin_example
    SHELL=/bin/bash
    XDG_CONFIG_DIRS=/etc/xdg
    XDG_MENU_PREFIX=lxde-pi-
    COGL_DRIVER=gles2
    LANGUAGE=en_US.UTF-8
    _LXSESSION_PID=1054
    SSH_AUTH_SOCK=/tmp/ssh-5z5QnJSGjpxR/agent.1054
    XDG_CONFIG_HOME=/home/pi/.config
    DESKTOP_SESSION=LXDE-pi
    SSH_AGENT_PID=1103
    NO_AT_BRIDGE=1
    XDG_SEAT=seat0
    PWD=/home/pi/GitHub/os420/practice
    LOGNAME=pi
    QT_QPA_PLATFORMTHEME=qt5ct
    XDG_SESSION_TYPE=tty
    GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1
    _=/usr/bin/printenv
    XAUTHORITY=/home/pi/.Xauthority
    DESKTOP_STARTUP_ID=lxpanel-1150-raspberrypi-/usr/bin/emacs-0_TIME59588
    WINDOWPATH=1
    MOTD_SHOWN=pam
    HOME=/home/pi
    LANG=en_US.UTF-8
    LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
    XDG_CURRENT_DESKTOP=LXDE
    V3D_IGNORE_SCANOUT_USAGES=1
    XDG_SESSION_CLASS=user
    TERM=dumb
    USER=pi
    DISPLAY=:0
    SHLVL=1
    XDG_VTNR=1
    XDG_SESSION_ID=1
    XDG_RUNTIME_DIR=/run/user/1000
    CLUTTER_DRIVER=gles2
    LC_ALL=en_US.UTF-8
    XDG_DATA_DIRS=/usr/share/fkms:/usr/local/share:/usr/share/raspi-ui-overrides:/usr/share:/usr/share/gdm:/var/lib/menu-xdg
    HUSHLOGIN=FALSE
    PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games
    SAL_USE_VCLPLUGIN=gtk3
    DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
    MAIL=/var/mail/pi
    TEXTDOMAIN=Linux-PAM
    #+end_example

  * [ ] How many different environment variables are there? (Make sure
    you removed potential duplicates.)

    #+name: count
    #+begin_src bash
      printenv | uniq | wc -l
      printenv | wc -l
    #+end_src

    #+RESULTS: count
    : 44
    : 44

  * [ ] You can also print individual variables with ~printenv~,
    e.g. ~$USER~.

    #+name: user
    #+begin_src bash
      printenv USER
    #+end_src

    #+RESULTS: user
    : pi

  * [ ] The bash command ~set~ does the same thing, or does it? Write
    a pipe that tees the output of ~cat~ to a file ~set.txt~ to view
    later, and counts its lines.

    #+name: set
    #+begin_src bash :results output
      set | cat | tee set.txt | wc -l
    #+end_src

    #+RESULTS: set
    : 68

  * [ ] You already know another way of printing variable values -
    with ~echo~. Print the value of ~HOME~ using this command.

    #+name: echo
    #+begin_src bash
      echo $HOME
    #+end_src

    #+RESULTS: echo
    : /home/pi

  * [ ] Neither ~set~ nor ~printenv~ display aliases. To see them,
    open an Emacs shell with ~M-x shell~ and enter ~alias~ without
    arguments at the prompt. This is what I see on my Pi:

    #+name: alias
    #+begin_example bash
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias ls='ls --color=auto'
    #+end_example

  * [ ] Go back to the shell buffer and create an alias ~dh~ for the
    human readable file system disk space usage information. Check the
    man page for ~df~ if necessary.

    #+name: df
    #+begin_example bash
      alias dh='df --human-readable'
    #+end_example

  * [ ] Now check the alias listing again. This is what I see on my
    Pi:

    #+name: df1
    #+begin_example bash
    pi@raspberrypi:~/GitHub/os420$ alias
    alias dh='df --human-readable'
pp    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias ls='ls --color=auto'
    #+end_example

* Interesting variables

  Your specific environment may differ from the entries of this list,
  but you're likely to see these variables.

  Check their values out with ~printenv~ or ~echo~ (see below). Don't
  worry if some values are missing - they vary with the distribution.

  | VARIABLE | CONTENT                            |
  |----------+------------------------------------|
  | DISPLAY  | Graphical display name (~:0~)      |
  | EDITOR   | Program used for text editing      |
  | SHELL    | Name of your shell program         |
  | HOME     | Pathname of your home directory    |
  | LANG     | Character set of your language     |
  | OLDPWD   | Previous working directory         |
  | PAGER    | Program for paging output (~less~) |
  | PS1      | Shell prompt string 1              |
  | PWD      | Current working directory          |
  | TERM     | Name of terminal type              |
  | TZ       | Your time zone (UTC)               |
  | USER     | Your user name                     |

  #+begin_src bash :results output
    echo "DISPLAY": $DISPLAY
    echo "EDITOR": $EDITOR
    echo "SHELL": $SHELL
    echo "HOME": $HOME
    echo "LANG": $LANG
    echo "OLDPWD:" $OLDPWD
    echo "PAGER:" $PAGER
    echo "PATH:" $PATH
    echo "PS1:" $PS1
    echo "PWD:" $PWD
    echo "TERM:" $TERM
    echo "TZ:" $TZ
    echo "USER:" $USER
  #+end_src

  #+RESULTS:
  #+begin_example
  DISPLAY: :0
  EDITOR:
  SHELL: /bin/bash
  HOME: /home/pi
  LANG: en_US.UTF-8
  OLDPWD:
  PAGER:
  PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games
  PS1:
  PWD: /home/pi/GitHub/os420/practice
  TERM: dumb
  TZ:
  USER: pi
  #+end_example

  * [ ] Inside Org-mode, the value of ~TERM~ is most likely
    ~dumb~. Compare this with its value 1) on the Emacs ~*shell*~,
    and 2) in the regular terminal.

    This is what I see on my Pi in the terminal:
    #+begin_example bash
      xterm-256color
    #+end_example

  * [ ] The shell prompt string ~PS1~ also won't be displayed inside
    Org-mode. You can display it on the Emacs shell (or in the
    terminal):

    #+begin_example bash
      ${debian_chroot:+($debian_chroot)}\u@\h:\w\$
    #+end_example

* Starting the environment

  * When you log on, ~bash~ starts and reads its startup files

  * The startup files are configuration scripts that defined the
    environment for all users

  * Next, ~bash~ reads startup files in your ~HOME~ directory to
    define your personal user environment

  * The exact sequence depends on the type of shell session (login
    sessions when you're prompted, or non-login session, e.g. when you
    open a terminal in the GUI).

  * Here is a list of some important startup files that you can find
    on your system. In Emacs, you can just go to the file directly.

    | FILE             | CONTENTS                          |
    |------------------+-----------------------------------|
    | /etc/profile     | Global script for all users       |
    | ~/.bash.profile  | User's personal startup file      |
    | ~/.bash_login    | If ~/.bash_profile not found      |
    | ~/.profile       | If the previous two are not found |
    | /etc/bash.bashrc | Global GUI config file            |
    | ~/.bashrc        | Personal GUI config file          |

  * [ ] How many configuration files do you have in your home
    directory? Use ~grep~ with the ~-l~ option and ~wc~ in a pipe to
    get the answer.

    #+name: startupfiles
    #+begin_src bash
      cd /home/pi
      ls ./ |grep -l .* | wc -l
    #+end_src

    #+RESULTS: startupfiles
    : 16

  * In addition to reading the startup files listed, non-login shells
    inherit the environment from their parent process (login shell)

  * [ ] Take a look at your ~.bashrc~ file in the ~HOME~
    directory. Can you identify any of the settings?

* What's in a startup file

  * A typical ~.bash_profile~ looks like this:

    #+name: bash_profile
    #+begin_example bash
      #.bash_profile

      # Get the aliases and functions
      if[-f ~/.bashrc ]; then
          . ~/.bashrc
      fi

      # User specific environment and startup programs

      PATH=$PATH:$HOME/bin
      export PATH
    #+end_example

  * Lines beginning with ~#~ are comments and are not read

  * The if statement is a compound command, translated:

    #+begin_quote
    "If the file ~/.bashrc exists, then read the ~/.bashrc file."
    #+end_quote

  * At the end, the ~PATH~ variable is extended by a directory so that
    personal files in that directory can be found. What type of files
    are likely to be stored in ~$HOME/bin~?

  * [ ] Try this parameter expansion yourself - not: there must not be
    any empty spaces in the parameter definition!

    1) Define ~foo~ to be the string ~"This is some "~
    2) Display ~foo~
    3) Expand ~foo~ by the string ~"text."~
    4) Display the expanded ~foo~.

    #+name: expansion
    #+begin_src bash :results output
      foo="This is some "
      echo $foo
      foo=$foo"text."
      echo $foo
    #+end_src

    #+RESULTS: expansion
    : This is some
    : This is some text.

  * Lastly, the ~export PATH~ command tells the shell to make the
    contents of ~PATH~ available to all child processes of this shell.

  * Child processes of a parent process are all processes spawned in
    it. You can see them with the command ~ps -a~

  #+begin_src bash :results output
    ps -a
  #+end_src

  #+RESULTS:
  #+begin_example
    PID TTY          TIME CMD
    924 tty1     00:00:00 bash
   1027 tty1     00:00:00 startx
   1049 tty1     00:00:00 xinit
   1050 tty1     00:03:16 Xorg
   1054 tty1     00:00:00 lxsession
   1145 tty1     00:02:50 mutter
   1148 tty1     00:00:00 lxpolkit
   1150 tty1     00:00:16 lxpanel
   1151 tty1     00:00:02 pcmanfm
   1158 tty1     00:00:00 applet.py
   1477 tty1     00:04:13 emacs
   2574 tty1     00:03:33 chromium-browse
   2601 tty1     00:00:00 chromium-browse
   2602 tty1     00:00:00 chromium-browse
   2605 tty1     00:00:00 chromium-browse
   2627 tty1     00:02:57 chromium-browse
   2631 tty1     00:00:54 chromium-browse
   2638 tty1     00:00:01 chromium-browse
   2644 tty1     00:00:00 chromium-browse
   2716 tty1     00:00:29 chromium-browse
   2807 tty1     00:02:52 chromium-browse
   2900 tty1     00:01:18 chromium-browse
   2940 tty1     00:00:03 chromium-browse
   2941 tty1     00:00:00 chromium-browse
   2968 tty1     00:01:12 chromium-browse
   3020 tty1     00:00:03 lxterminal
   3033 pts/1    00:00:00 ssh
   4594 tty1     00:00:33 chromium-browse
   4608 tty1     00:00:01 chromium-browse
   4897 tty1     00:00:00 chromium-browse
  #+end_example
