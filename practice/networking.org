#+TITLE:Networking
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:networking lecture & practice for CSC420 Operating Systems Spring 2022 Lyon College
#+STARTUP:overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :results output
#+PROPERTY: header-args:bash :exports both
* README

  * This file accompanies lectures on the shell and ~bash(1)~. To gain
    practice, you should type along in your own Org-mode file. You
    have to have Emacs and my ~.emacs~ file installed on your PC or
    the Pi you're working with.

  * This section is based on chapter 16 of Shotts, The Linux Command
    Line (2e), NoStarch Press (2019) - "Networking".

  * To make this easier, use the auto expansion (~<s~). This will only
    work if you have my ~.emacs~ file ([[https://tinyurl.com/lyonemacs][from GDrive]]) installed and the
    ~org-tempo~ library loaded.

  * Add the following two lines at the top of your file, and activate
    each line with ~C-c C-c~ (this is confirmed in the echo area as
    ~Local setup has been refreshed~)):
    #+begin_example
    #+PROPERTY: header-args:bash :results output
    #+end_example

  * Remember that ~C-M-\~ inside a code block indents syntactically
    (on Windows, this may only work if you have a marked region - set
    the mark with ~C-SPC~).

  * To *not* see the emphatic characters like ~ or * or / in the Org file
    text, run the following code chunk (or put the code in your ~/.emacs~
    file): if successful, you should see ~"t"~ in the minibuffer.

    #+begin_src emacs-lisp :results silent
      (setq-default org-hide-emphasis-markers t)
    #+end_src

    If you don't put it in your ~/.emacs~ file, the command will only work
    for the current Emacs session.

  * If you have difficulty distinguishing the code blocks from the
    documentation, change your Emacs theme with ~M-x custom-themes~ -
    ~Leuven~ is great if you like a light theme, or ~Manoj-dark~ if you
    like it dark.

* Overview

  * When it comes to networking, there is nothing that cannot be done
    with Linux.

  * Linux is used to build networking systems like firewalls,
    routers,name servers, network-attached storage (NAS) boxes, etc.

  * There is a vast number of commands - we focus on the most
    frequently used ones to monitor networks, transfer files and
    facilitate remote work:

    #+name: networking_cmds
    | COMMAND    | MEANING                                      |
    |------------+----------------------------------------------|
    | ~ping~       | Send an echo request to network hosts        |
    | ~traceroute~ | Print the route packets trace to a host      |
    | ~ip~         | Show/manipulate routing, devices, tunnels    |
    | ~netstat~    | Print network connections, routing tables,   |
    |            | interface statistics, masquerade connections |
    |            | and multicast memberships                    |
    | ~ftp~        | Internet file transfer program               |
    | ~irc~        | Internet relay chat program                  |
    | ~wget~       | Non-interactive network downloader           |
    | ~ssh~        | OpenSSH secure shell client (remote login)   |

  * This section also assumes some familiarity with the concepts
    - Internet Protocol (IP) address
    - Domain and host name
    - Uniform Resource Identifier (URI)

* Internet addresses

  * An IP address is a numerical label like ~192.168.1.10~

  * It identifies a network interface and enables connections to host
    computers (computers with an OS and user access)

  * There are two types of (standard) Internet protocols, IPv4
    (32-bit) and IPv6 (128-bit)

  #+attr_html: :width 500px
  #+caption: WiFi information on a Windows Box
  [[./img/wifi.png]]

  * The IPv4 and IPv6 addresses are dynamical

  * The MAC address is static

  * The DHCP (Dynamical Host Configuration Protocol) assigns IP
    addresses to devices connected to the network

  * [ ] Check if a ~dhcp~ process runs on your computer. Use two
    methods on the terminal or on an Emacs shell:

    1) process check with ~ps aux~ - use ~grep~ to search for ~dhcp~.

       #+begin_src bash :results output
         ps aux | grep --exclude=grep dhcp
       #+end_src

       #+RESULTS:
       : root       534  0.0  0.0   2876  1948 ?        Ss   Apr15   0:01 /usr/sbin/dhcpcd -b -q
       : pi       17861  0.0  0.0   7452   572 ?        S    21:59   0:00 grep --exclude=grep dhcp

    2) search for ~dhcp~ in the output of the ~systemctl~ service program
       (the program that talks to ~systemd~). Pipe the output of
       ~systemctl status~ into ~grep~.

       #+begin_src bash :results output
         systemctl status | grep dhcp
       #+end_src

       #+RESULTS:
       :            │   │ └─17858 grep dhcp
       :              ├─dhcpcd.service
       :              │ ├─534 /usr/sbin/dhcpcd -b -q

    * [ ] Find out what the active flags ~-b -q~ for the ~dhcpcd(8)~
      program mean.

      #+begin_quote
      ~-b~ stands for "background" (startup scripts)
      ~-q~ stands for "quiet" (level of system messages)
      #+end_quote

    * On the man page, you find the information that this daemon
      program implements an ~RFC~ - a [[https://networkencyclopedia.com/request-for-comments-rfc/][Request For Comment]]. This is the
      traditional (since 1969) title for standard-setting documents for
      the Internet, or more specifically for TCP/IP (Transmission
      Control Protocol/Internet Protocol)

* The Internet and the Web

  * The World-Wide Web is a collection of web pages on the Internet

  * Similar to a shopping mall with road access

  * Web locations and Internet addresses are linked but not identical

  * The Internet's name space is structured by standardized strings:
    [[https://www.w3.org/Addressing/URL/uri-spec.html][Universal Resource Identifiers]] (URI), a Universal Resource
    Locators (URL) and a Universal Resource Name (URN).

  * A URI contains both URL and URN.

  * URI syntax:

    #+begin_example
      scheme:[//authority]path[?query][#fragment]
    #+end_example

    | SYNTAX ELEMENT | EXAMPLES                        |
    |----------------+---------------------------------|
    | Scheme         | http, file, ftp, data, irc      |
    | Authority      | userinfo@, host (IP), port (80) |
    | Path           | path to the resource            |
    | Query          | query string                    |
    | Fragment       | direction to secondary resource   |

  * URI Examples:

    | URI                                                             | WHAT                  |
    |-----------------------------------------------------------------+-----------------------|
    | mailto:birkenkrahe@lyon.edu                                     | user mail             |
    | [[https://github.com/birkenkrahe/os420/blob/main/pi/README.org#my-first-pi][https://github.com/birkenkrahe/os420/.../README.org#my-first-pi]] | GitHub link           |
    | [[http://ftp.gnu.org/gnu/emacs/][http://ftp.gnu.org/gnu/emacs/]]                                   | GNU Emacs file server |
    | [[https://www.irc.info/networks/freenode][irc.freenode.net]]                                                | Internet Relay Chat   |

* Network address on Windows

  * Go to Settings > Network & Internet > Wi-Fi > Hardware properties

    Here you see the IPv4 adress, e.g. for my computer: 192.168.1.116

  * On Windows, the ~hostname~ command only gives you the
* Examining and monitoring a network

  Look at the man page for each of these programs if you're interested
  in learning more, and try some of the many options. 

** Knock-knock who's there: ~ping~

   * The ~ping~ command sends a special network packet called an ~ICMP
     ECHO_REQUEST~ to a specified host.

   * Most network devices receiving this packet will reply to it,
     allowing the network connection to be verified.

   * You can configure the network connection to ignore these packets
     (for security reasons).

   * A typical packet reply looks like this:

     #+begin_example
     64 bytes from ord38s29-in-f14.1e100.net (142.250.191.142): icmp_seq=3 ttl=57 time=31.9 ms
     #+end_example

     It contains the packet size, the target IP, time to live and
     transmitting time information.

   * When you interrupt the communication with ~C-c C-c~ or ~CTRL-c~, you
     get some stats:

     #+begin_example
     --- google.com ping statistics ---
     2 packets transmitted, 2 received, 0% packet loss, time 1002ms
     rtt min/avg/max/mdev = 31.358/31.437/31.517/0.079 ms
     #+end_example

   * A properly performing (transparent) network will exhibit 0 %
     packet loss and indicate that different network elements
     (interface cards, cabling, routing, gateways) are OK.

   * [ ] Go to the terminal or to an Emacs shell and ping Lyon College,
     and then Google. Do you see a difference?

     #+begin_example
       ping lyon.edu
       ping google.com
     #+end_example

** What's the route: ~traceroute~

   * This program lists all the hops network traffic takes to get from
     the local system to the specified host. Here is the route from
     my house to lyon.edu:

     #+begin_example
~/GitHub $ traceroute lyon.edu
traceroute to lyon.edu (40.119.1.254), 30 hops max, 60 byte packets
 1  Docsis-Gateway (192.168.1.1)  8.721 ms  8.383 ms  8.302 ms
 2  * * *
 3  173-219-255-40.suddenlink.net (173.219.255.40)  18.387 ms  18.322 ms  18.240 ms
 4  173-219-221-143.suddenlink.net (173.219.221.143)  40.121 ms  39.998 ms  39.903 ms
 5  173-219-221-138.suddenlink.net (173.219.221.138)  39.556 ms  39.471 ms  39.343 ms
 6  173-219-17-110.suddenlink.net (173.219.17.110)  38.896 ms  42.320 ms  41.960 ms
 7  173-219-152-172.suddenlink.net (173.219.152.172)  41.850 ms  41.737 ms  41.700 ms
 8  66-76-232-151-chic.tex.sta.suddenlink.net (66.76.232.151)  41.498 ms  35.773 ms  35.771 ms
 9  ae35-0.icr01.ch4.ntwk.msn.net (104.44.237.19)  45.126 ms  45.163 ms ae30-0.icr01.ch2.ntwk.msn.net (104.44.237.17)  35.556 ms
10  be-100-0.ibr01.ch2.ntwk.msn.net (104.44.11.252)  58.979 ms be-120-0.ibr02.ch2.ntwk.msn.net (104.44.11.13)  56.224 ms be-100-0.ibr01.ch4.ntwk.msn.net (104.44.11.7)  53.910 ms
11  be-6-0.ibr02.dsm05.ntwk.msn.net (104.44.18.217)  60.892 ms be-4-0.ibr01.dsm05.ntwk.msn.net (104.44.18.215)  53.930 ms  53.865 ms
12  be-7-0.ibr02.sn1.ntwk.msn.net (104.44.16.38)  53.861 ms  53.767 ms be-9-0.ibr01.sn1.ntwk.msn.net (104.44.16.28)  54.303 ms
13  ae100-0.icr01.sn6.ntwk.msn.net (104.44.23.78)  64.181 ms ae124-0.icr03.sn1.ntwk.msn.net (104.44.11.63)  54.230 ms ae122-0.icr02.sn1.ntwk.msn.net (104.44.23.68)  54.702 ms
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *
~/GitHub $
     #+end_example

     - Traversing the entire route requires 13 routers.
     - Each router stop is accompanied by 3 rount-trip times.
     - For routers that do not give identifying information (because
       of network congestion, firewalls, etc.) you see asterisks
     - The ~-T~ and ~-I~ options (different probes) sometimes gives more
       information (and requires ~sudo~ rights)

   * [ ] Check the ~traceroute~ to ~lyon.edu~ yourself, and contrast it
     again with the ~traceroute~ to ~google.com~. Check if ~-T~ or ~-I~ make a
     difference.


** What's interfaced: ~ip~ and ~ifconfig~

   * The ~ip(8)~ program is a multi-purpose network configuration tool

   * The ~ifconfig(8)~ program is the older (deprecated) version of ~ip~

   * [ ] Run ~ip a~ in the code block below.

     #+begin_src bash :results output
       ip a
     #+end_src

     #+RESULTS:
     #+begin_example
     1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
	 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
	 inet 127.0.0.1/8 scope host lo
	    valid_lft forever preferred_lft forever
	 inet6 ::1/128 scope host 
	    valid_lft forever preferred_lft forever
     2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
	 link/ether e4:5f:01:60:ae:84 brd ff:ff:ff:ff:ff:ff
     3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
	 link/ether e4:5f:01:60:ae:85 brd ff:ff:ff:ff:ff:ff
	 inet 192.168.1.160/24 brd 192.168.1.255 scope global dynamic noprefixroute wlan0
	    valid_lft 2621sec preferred_lft 1993sec
	 inet6 fe80::b5d0:307e:bbaf:151d/64 scope link 
	    valid_lft forever preferred_lft forever
     #+end_example

     - My system has three network interfaces: 
     - ~lo~ for loopback, used by the OS to talk to itself
     - ~eth~ for Ethernet interface
     - ~wlan0~ for the WiFi interface

   * When peforming diagnostics, look for the word ~UP~ in the first
     line (which means it's enabled), and a valid IP address in the
     ~inet~ field. E.g. I only have WiFi right now, and no Ethernet.

   * [ ] Run ~ifconfig -a~ in the code block below. This command is a
     little easier to understand, I think.

     #+begin_src bash :results output
       ifconfig -a
     #+end_src

     #+RESULTS:
     #+begin_example
     eth0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
             ether e4:5f:01:60:ae:84  txqueuelen 1000  (Ethernet)
             RX packets 0  bytes 0 (0.0 B)
             RX errors 0  dropped 0  overruns 0  frame 0
             TX packets 0  bytes 0 (0.0 B)
             TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
             inet 127.0.0.1  netmask 255.0.0.0
             inet6 ::1  prefixlen 128  scopeid 0x10<host>
             loop  txqueuelen 1000  (Local Loopback)
             RX packets 186  bytes 16186 (15.8 KiB)
             RX errors 0  dropped 0  overruns 0  frame 0
             TX packets 186  bytes 16186 (15.8 KiB)
             TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     wlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
             inet 192.168.1.160  netmask 255.255.255.0  broadcast 192.168.1.255
             inet6 fe80::b5d0:307e:bbaf:151d  prefixlen 64  scopeid 0x20<link>
             ether e4:5f:01:60:ae:85  txqueuelen 1000  (Ethernet)
             RX packets 818249  bytes 181591941 (173.1 MiB)
             RX errors 0  dropped 0  overruns 0  frame 0
             TX packets 68467  bytes 10239884 (9.7 MiB)
             TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     #+end_example

** What's on the net: ~netstat~

   * This program is used to examine network settings and statistics.

   * [ ] Run ~netstat -ie~ to examine network interfaces.

     #+begin_src bash :results output
     netstat -ie
     #+end_src

     #+RESULTS:
     #+begin_example
     Kernel Interface table
     eth0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
	     ether e4:5f:01:60:ae:84  txqueuelen 1000  (Ethernet)
	     RX packets 0  bytes 0 (0.0 B)
	     RX errors 0  dropped 0  overruns 0  frame 0
	     TX packets 0  bytes 0 (0.0 B)
	     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
	     inet 127.0.0.1  netmask 255.0.0.0
	     inet6 ::1  prefixlen 128  scopeid 0x10<host>
	     loop  txqueuelen 1000  (Local Loopback)
	     RX packets 186  bytes 16186 (15.8 KiB)
	     RX errors 0  dropped 0  overruns 0  frame 0
	     TX packets 186  bytes 16186 (15.8 KiB)
	     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     wlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
	     inet 192.168.1.160  netmask 255.255.255.0  broadcast 192.168.1.255
	     inet6 fe80::b5d0:307e:bbaf:151d  prefixlen 64  scopeid 0x20<link>
	     ether e4:5f:01:60:ae:85  txqueuelen 1000  (Ethernet)
	     RX packets 819114  bytes 181716818 (173.2 MiB)
	     RX errors 0  dropped 0  overruns 0  frame 0
	     TX packets 68692  bytes 10296698 (9.8 MiB)
	     TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

     #+end_example

   * The output of ~netstat -ie~ looks similar to the ~ifconfig~ command
     because it focuses on network interfaces. Only ~lo~ and ~wlan0~
     transport any packets.

   * [ ] Run ~netstat -r~ to see the routing table, which shows how the
     network is configured to send packets from network to network:

     #+begin_src bash :results output
       netstat -r
     #+end_src

     #+RESULTS:
     : Kernel IP routing table
     : Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
     : default         Docsis-Gateway  0.0.0.0         UG        0 0          0 wlan0
     : 192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 wlan0

     - This is a typical table for a client on a local area network
       (LAN) behind a firewall/router. The first line shows the
       destination IP, ~192.168.1.0~. The last 0 means that the adress
       refers to multiple hosts.

     - The Gateway is the name or router to go from the current host
       to the destination network.

     - The I[nter]face to connect is WiFi (~wlan0~). 

   * [ ] Run the ~hostname -I~ command to see your own host on your LAN:

     #+begin_src bash :results output
     hostname -I
     #+end_src

     #+RESULTS:
     : 192.168.1.160 

     Mine is ~192.168.1.160~. One of about 20 network devices in my
     house, including: PS5, SmartTV, Kindle tablets, PCs, Mac,
     Raspberry Pi (this is it), network printers etc. 

* Transporting files over a network with ~ftp~ and ~wget~
** FTP

  * ~ftp~ (File Transfer Protocol) is a "classic" program. It is
    supported by all web browsers.

  * [ ] Check is the ~ftp~ daemon ~ftpd~ is awake.

    #+begin_src bash :results output
    systemctl status | grep ftpd
    #+end_src

    #+RESULTS:
    :            │   │ └─19490 grep ftpd

  * [ ] Check if the program ~ftp~ is even available/installed.

    #+begin_src bash :results silent
    which ftp
    #+end_src

  * FTP in its original form is *not safe* because it sends account
    names and passwords in clear text, i.e. unencrypted. Anyone
    sniffing the network can see them.

  * Therefore, all FTP traffic on the Internet is done by /anonymous/
    FTP servers that allow you to login using the username /anonymous/
    and a meaningless password. 

  * Try ~lftp~ - a better FTP client. On Windows, I used Cyberduck years
    ago. Dedicated clients offer a lot more features.

** An FTP session

    #+attr_html: :width 500px
    #+caption: FTP session example
    [[./img/ftp.png]]


  * [ ] Install ~ftp~ as ~sudo~ - use an Emacs shell or a terminal for that.

  * [ ] In a terminal or on an Emacs shell, run ~ftp~

  * [ ] On the ~ftp>~ shell, type ~help~ to see the available commands

  * [ ] Open a connection with ~open~

  * [ ] As target IP address, enter ~ftp.gnu.org~

  * [ ] Login as ~anonymous~

  * [ ] List the current directory with ~ls~

  * [ ] Get the ~README~ file with ~get README~

  * [ ] Rename ~README~ on your computer to ~README1~

  * [ ] Send ~README1~ to the other location with ~send README1~

  * [ ] Close the connection with ~close~ and quit with ~quit~

** wget 

   * ~wget~ is a tool for file downloading both from web and FTP
     sites. It exhibits network resilience, e.g. it will keep trying
     to get the job done even if the network is slow or unstable. It
     does the job in the background 

   * ~wget~ uses "recursive downloading" and recreates the entire file
     structure that it finds remotely at the local site while
     respecting the local "Robot Exclusion Standard" of the ~robots.txt~
     file[fn:1].

   * You can download files, directories, and entire sites.

   * [ ] Download the Lyon College landing page with ~wget~ using
     ~lyon.edu~ as the only command. The program will substitute any
     other information necessary. 
     - Check the current directory for the result (~index.html~).

     #+begin_src bash :results silent
     wget lyon.edu
     #+end_src

     - Go to a terminal (or the Emacs shell) and run the command there
       again to see the full screen message:

       #+attr_html: :width 700px
       #+caption: wget terminal screen message
       [[./img/wget.png]]

     - The man page is better-than-average and highly readable. 


     - In Emacs, you can also go to the ~Dired~ buffer with ~C-x d~ and
       type ~! chromium browswer RET~ on the file ~index.html~. This will
       open the page locally in a browser.

       #+attr_html: :width 500px
       #+caption: local copy of lyon.edu/index.html in Chromium browser
       [[./img/lyon.png]]

* Secure communication with ~ssh~

  * Popular remote access programs included ~rlogin~ and ~telnet~

  * Like ~FTP~ these transmit all their communications in cleartext

  * ~ssh~ (Secure SHell) on the other hand:

    - authenticates that the remote host is who it says it is
      (preventing so-called "man-in-the-middle" attacks)

    - encrypts all of the communication between the local and remote
      hosts

  * On Raspberry Pi, you may need to enable ~ssh~ using the ~sudo
    raspi-config~ terminal command. This opens a screen dialog.

  * [ ] To check if ~ssh~ is active, run

    #+begin_src bash :results output
      ps aux | grep sshd
    #+end_src

    #+RESULTS:
    : root       556  0.0  0.1  12372  6004 ?        Ss   Apr15   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
    : root     17230  0.0  0.1  14484  7052 ?        Ss   Apr20   0:00 sshd: pi [priv]
    : pi       17236  0.0  0.1  14484  4464 ?        S    Apr20   0:00 sshd: pi@pts/1
    : root     17295  0.0  0.1  14484  6920 ?        Ss   Apr20   0:00 sshd: pi [priv]
    : pi       17301  0.0  0.1  14484  4500 ?        S    Apr20   0:00 sshd: pi@pts/2
    : pi       22899  0.0  0.0   7452   568 ?        S    08:45   0:00 grep sshd
    
    I get this result, which shows that I (as ~pi~) have one active
    secure shell connections. It is controlled by ~root~ and asleep.

    #+begin_example
    : root     17230  Ss   Apr20   0:00 sshd: pi [priv]
    : pi       17236  S    Apr20   0:00 sshd: pi@pts/1
    #+end_example

    Here are the Emacs buffers that show the remote connection:

    #+begin_example
    %  /rclone:pi@gdrive:/       1971 Dired by name    /rclone:pi@gdrive:/
    * *tramp/rclone pi@gdrive*     0 Fundamental      
    #+end_example

  * SSH consists of two parts:
    - An SSH server runs on the /remote host/, listening for incoming
      connections by default on port 22
    - An SSH client runs on the /local system/ to communicate with the
      remote server.
  
  * To enable a system to receive remote connections, it must have the
    OpenSSH-server package installed, configured, and running, and (if
    the system is behind a firewall) it must allow incoming
    connections on TCP port 22.

  * [ ] Connect with your neighboring Pi using SSH.

    - Make sure ssh is alive and running: type ~systemctl status ssh~ in
      a terminal or Emacs shell or run the block below and check the file.

      #+begin_src bash :results output
      systemctl status ssh > ssh.status
      cat ssh.status
      #+end_src

      #+RESULTS:
      #+begin_example
      ● ssh.service - OpenBSD Secure Shell server
	   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
	   Active: active (running) since Fri 2022-04-15 12:48:23 CDT; 5 days ago
	     Docs: man:sshd(8)
		   man:sshd_config(5)
	  Process: 531 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
	 Main PID: 556 (sshd)
	    Tasks: 1 (limit: 4915)
	      CPU: 4.204s
	   CGroup: /system.slice/ssh.service
		   └─556 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups

      Apr 20 21:06:12 raspberrypi sshd[17170]: Connection reset by authenticating user pi 192.168.1.116 port 64112 [preauth]
      Apr 20 21:07:34 raspberrypi sshd[17201]: Connection closed by 192.168.1.116 port 64135 [preauth]
      Apr 20 21:09:37 raspberrypi sshd[17209]: Accepted password for pi from 192.168.1.116 port 64169 ssh2
      Apr 20 21:09:37 raspberrypi sshd[17209]: pam_unix(sshd:session): session opened for user pi(uid=1000) by (uid=0)
      Apr 20 21:10:20 raspberrypi sshd[17230]: Accepted password for pi from 192.168.1.116 port 64181 ssh2
      Apr 20 21:10:20 raspberrypi sshd[17230]: pam_unix(sshd:session): session opened for user pi(uid=1000) by (uid=0)
      Apr 20 21:10:43 raspberrypi sshd[17295]: Accepted password for pi from 192.168.1.116 port 64184 ssh2
      Apr 20 21:10:43 raspberrypi sshd[17295]: pam_unix(sshd:session): session opened for user pi(uid=1000) by (uid=0)
      Apr 20 21:11:49 raspberrypi sshd[17332]: Accepted password for pi from 192.168.1.116 port 64193 ssh2
      Apr 20 21:11:49 raspberrypi sshd[17332]: pam_unix(sshd:session): session opened for user pi(uid=1000) by (uid=0)
      #+end_example

    - Find your own and the other party's hostname with ~hostname -I~:
      this is the only information you need, apart from the username.

      #+begin_src bash :results output
      hostname -I
      #+end_src

      #+RESULTS:
      : 192.168.1.160 

    - In a terminal: enter ~ssh pi@hostname~ then enter the password,
      which is ~ly0Np1_Numb3r_xx~ where ~xx~ is the number of your
      Pi. ~hostname~ is the IP address you just obtained.

    - If successful, check that you're on the other machine by
      checking the SSH ~systemctl status~ and/or the ~hostname~. You can
      even open Emacs here with ~emacs -nw~ (non-graphical Emacs).

    - In Emacs: open a ~Dired~ buffer with ~C-x d~ and at the prompt, enter

      #+begin_example
      /ssh:pi@hostname:~/
      #+end_example

      You should now see the other computer's ~/home/pi~ directory. Open
      a shell with ~M-x shell~ and you'll see that it will open on the
      other computer. 

* Emacs special

  * [[https://www.gnu.org/software/tramp/tramp-emacs.html][Tramp]] ("Transparent Remote (file) Access, Multiple Protocol" is a
    built-in GNU Emacs package that provides remote file editing.

  * Tramp works directly with Dired using a command like:

    #+begin_example
    C-x d /ssh:pi@192.168.1.160:~/
    #+end_example

    to connect to a user ~pi~ on a local network machine. You can open a
    shell on the other machine, too, and work remotely at ease.

  * The ~rclone~ program e.g. uses Tramp as an external method to
    connect to network servers like GDrive, or to facilitate cloud
    backup.

* Challenge: How to connect your Pi to GDrive

  Sources: [[https://rclone.org/drive/][rclone.org/drive]].

  1) Install rclone on Raspbian
     #+begin_example
     $ sudo apt-get install rclone
     #+end_example

  2) Change file permissions of ~$HOME/.config/rclone~ to ~rwx~ for
     owner only
     #+begin_example
     $ chmod 0700 ./.config/rclone  # change permissions
     $ ls -la ./.config/rclone      # check - you should see drwx------
     #+end_example

  3) Follow the detailed instructions in [[https://rclone.org/drive/][rclone.org/drive]] until you
     see the ~Success!~ web page after connecting rclone to GDrive

  #+caption: Selecting GDrive account for rclone
  #+attr_html: :width 600px
  [[./img/rclone1.png]]

  #+caption: Give rclone permission to access GDrive
  #+attr_html: :width 600px
  [[./img/rclone2.png]]


  #+begin_quote
  "Note that rclone runs a webserver on your local machine to collect
  the token as returned from Google if you use auto config mode. This
  only runs from the moment it opens your browser to the moment you
  get back the verification code. This is on http://127.0.0.1:53682/
  and this it may require you to unblock it temporarily if you are
  running a host firewall, or use manual mode."
  #+end_quote

  The access information is stored in
  ~$HOME/.config/rclone/rclone.conf~.

  You can now access your GDrive from the Pi from the command line
  with: ~rclone [cmd] gdrive:~, or inside GNU Emacs as an [[https://www.gnu.org/software/emacs/manual/html_node/tramp/External-methods.html][external
  method]]:~ ~C-x d  /rclone:gdrive:/~.

  #+caption: GDrive via rclone in Emacs
  #+attr_html: :width 600px
  [[./img/rclone.png]]

* TODO Summary
* Footnotes

[fn:1]This file specifies rules for web crawlers. If you have your own
web server somewhere with an Internet connection, you're likely to
have such a file. You can e.g. use it to block sites. It has a simple
syntax. [[https://syspree.com/create-robots-txt-file-guide/][Here is a simple guide]].
