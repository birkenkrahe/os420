#+TITLE:The Environment
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:environment practice for CSC420 Operating Systems Spring 2022 Lyon College
#+STARTUP:overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:bash :results output
#+PROPERTY: header-args:bash :exports both
* README

  * This file accompanies lectures on the shell and ~bash(1)~. To gain
    practice, you should type along in your own Org-mode file. You
    have to have Emacs and my ~.emacs~ file installed on your PC or
    the Pi you're working with.

  * To make this easier, use the auto expansion (~<s~). This will only
    work if you have my ~.emacs~ file ([[https://tinyurl.com/lyonemacs][from GDrive]]) installed.

  * Add the following two lines at the top of your file, and activate
    each line with ~C-c C-c~ (this is confirmed in the echo area as
    ~Local setup has been refreshed~)):
    #+begin_example
    #+PROPERTY: header-args:bash :results output
    #+end_example

  * Remember that ~C-M-\~ inside a code block indents syntactically
    (on Windows, this may only work if you have a marked region - set
    the mark with ~C-SPC~).
* What is it?

  * The environment is the information retained by the shell about our
    shell session

  * Programs use the data stored in the environment for
    configuration - e.g. when installing files, setting permissions

  * Knowing the environment helps us customize our shell experience
    (including shell scripting)

  * Types of data stored in the environment:

    | DATA                  | DESCRIPTION    | EXAMPLE             |
    |-----------------------+----------------+---------------------|
    | Shell variables       | Placed by bash | ~$PWD~              |
    | Environment variables | Placed by OS   | ~$HOME~             |
    | Aliases               | User-defined   | ~alias ll='ls -lh'~ |
    | Shell functions       | User-defined   | ~hello.sh~          |

    #+name: hello.sh
    #+begin_src bash
      !# /usr/bin/bash
      echo Hello world
    #+end_src

* Examining the environment

  * [ ] You can use the builtin bash programs ~set~, or the program
    ~printenv~ to view the environment.

    Pipe the output of ~printenv~ into ~cat~ to view it.

    #+name: environment
    #+begin_src bash :results output

    #+end_src

  * [ ] How many different environment variables are there? (Make sure
    you removed potential duplicates.)

    #+name: count
    #+begin_src bash


    #+end_src


  * [ ] You can also print individual variables with ~printenv~,
    e.g. ~$USER~.

    #+name: user
    #+begin_src bash

    #+end_src


  * [ ] The bash command ~set~ does the same thing, or does it? Write
    a pipe that tees the output of ~cat~ to a file ~set.txt~ to view
    later, and counts its lines.

    #+name: set
    #+begin_src bash :results output

    #+end_src

  * [ ] You already know another way of printing variable values -
    with ~echo~. Print the value of ~HOME~ using this command.

    #+name: echo
    #+begin_src bash

    #+end_src


  * [ ] Neither ~set~ nor ~printenv~ display aliases. To see them,
    open an Emacs shell with ~M-x shell~ and enter ~alias~ without
    arguments at the prompt. This is what I see on my Pi:

    #+name: alias
    #+begin_example bash
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias ls='ls --color=auto'
    #+end_example

  * [ ] Go back to the shell buffer and create an alias ~dh~ for the
    human readable file system disk space usage information. Check the
    man page for ~df~ if necessary.

    #+name: df
    #+begin_example bash
      alias dh='df --human-readable'
    #+end_example

  * [ ] Now check the alias listing again. This is what I see on my
    Pi:

    #+name: df1
    #+begin_example bash
    pi@raspberrypi:~/GitHub/os420$ alias
    alias dh='df --human-readable'
    alias egrep='egrep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias grep='grep --color=auto'
    alias ls='ls --color=auto'
    #+end_example

* Interesting variables

  Your specific environment may differ from the entries of this list,
  but you're likely to see these variables.

  Check their values out with ~printenv~ or ~echo~ (see below). Don't
  worry if some values are missing - they vary with the distribution.

  | VARIABLE | CONTENT                            |
  |----------+------------------------------------|
  | DISPLAY  | Graphical display name (~:0~)      |
  | EDITOR   | Program used for text editing      |
  | SHELL    | Name of your shell program         |
  | HOME     | Pathname of your home directory    |
  | LANG     | Character set of your language     |
  | OLDPWD   | Previous working directory         |
  | PAGER    | Program for paging output (~less~) |
  | PS1      | Shell prompt string 1              |
  | PWD      | Current working directory          |
  | TERM     | Name of terminal type              |
  | TZ       | Your time zone (UTC)               |
  | USER     | Your user name                     |

  #+begin_src bash :results output
    echo "DISPLAY": $DISPLAY
    echo "EDITOR": $EDITOR
    echo "SHELL": $SHELL
    echo "HOME": $HOME
    echo "LANG": $LANG
    echo "OLDPWD:" $OLDPWD
    echo "PAGER:" $PAGER
    echo "PATH:" $PATH
    echo "PS1:" $PS1
    echo "PWD:" $PWD
    echo "TERM:" $TERM
    echo "TZ:" $TZ
    echo "USER:" $USER
  #+end_src


  * [ ] Inside Org-mode, the value of ~TERM~ is most likely
    ~dumb~. Compare this with its value 1) on the Emacs ~*shell*~,
    and 2) in the regular terminal.

    This is what I see on my Pi in the terminal:
    #+begin_example bash
      xterm-256color
    #+end_example

  * [ ] The shell prompt string ~PS1~ also won't be displayed inside
    Org-mode. You can display it on the Emacs shell (or in the
    terminal):

    #+begin_example bash
      ${debian_chroot:+($debian_chroot)}\u@\h:\w\$
    #+end_example

* Starting the environment

  * When you log on, ~bash~ starts and reads its startup files

  * The startup files are configuration scripts that defined the
    environment for all users

  * Next, ~bash~ reads startup files in your ~HOME~ directory to
    define your personal user environment

  * The exact sequence depends on the type of shell session (login
    sessions when you're prompted, or non-login session, e.g. when you
    open a terminal in the GUI).

  * Here is a list of some important startup files that you can find
    on your system. In Emacs, you can just go to the file directly.

    | FILE             | CONTENTS                          |
    |------------------+-----------------------------------|
    | /etc/profile     | Global script for all users       |
    | ~/.bash.profile  | User's personal startup file      |
    | ~/.bash_login    | If ~/.bash_profile not found      |
    | ~/.profile       | If the previous two are not found |
    | /etc/bash.bashrc | Global GUI config file            |
    | ~/.bashrc        | Personal GUI config file          |

  * [ ] How many configuration files do you have in your home
    directory? Use ~grep~ with the ~-l~ option and ~wc~ in a pipe to
    get the answer.

    #+name: startupfiles
    #+begin_src bash


    #+end_src

  * In addition to reading the startup files listed, non-login shells
    inherit the environment from their parent process (login shell)

  * [ ] Take a look at your ~.bashrc~ file in the ~HOME~
    directory. Can you identify any of the settings?

* What's in a startup file

  * A typical ~.bash_profile~ looks like this:

    #+name: bash_profile
    #+begin_example bash
      #.bash_profile

      # Get the aliases and functions
      if[-f ~/.bashrc ]; then
          . ~/.bashrc
      fi

      # User specific environment and startup programs

      PATH=$PATH:$HOME/bin
      export PATH
    #+end_example

  * Lines beginning with ~#~ are comments and are not read

  * The if statement is a compound command, translated:

    #+begin_quote
    "If the file ~/.bashrc exists, then read the ~/.bashrc file."
    #+end_quote

  * At the end, the ~PATH~ variable is extended by a directory so that
    personal files in that directory can be found. What type of files
    are likely to be stored in ~$HOME/bin~?

  * [ ] Try this parameter expansion yourself - not: there must not be
    any empty spaces in the parameter definition!

    1) Define ~foo~ to be the string ~"This is some "~
    2) Display ~foo~
    3) Expand ~foo~ by the string ~"text."~
    4) Display the expanded ~foo~.

    #+name: expansion
    #+begin_src bash :results output




    #+end_src


  * Lastly, the ~export PATH~ command tells the shell to make the
    contents of ~PATH~ available to all child processes of this shell.

  * Child processes of a parent process are all processes spawned in
    it. You can see them with the command ~ps -a~

  #+begin_src bash :results output

  #+end_src

